" don't bother with vi compatibility
set nocompatible

" configure Vundle
filetype on
filetype off

" install Vundle bundles
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
if filereadable(expand("~/git/dotfiles/vim/bundles.vim"))
  source ~/git/dotfiles/vim/bundles.vim
endif
call vundle#end()

" ensure ftdetect et al work by including this after the Vundle stuff
filetype plugin indent on
" enable syntax highlighting
syntax enable

set autoread                                                 " reload files when changed on disk, i.e. via `git checkout`
set backspace=2                                              " Fix broken backspace in some setups
set backupcopy=yes                                           " see :help crontab
set clipboard=unnamed                                        " yank and paste with the system clipboard
set directory-=.                                             " don't store swapfiles in the current directory
set encoding=utf-8
set expandtab                                                " expand tabs to spaces
set autoindent
set copyindent
set smartindent
set shiftround
set ignorecase                                               " case-insensitive search
set noincsearch                                                " search as you type
set hlsearch
set laststatus=2                                             " always show statusline
set list                                                     " show trailing whitespace
set listchars=tab:·\ ,trail:▫
set number                                                   " show line numbers
set ruler                                                    " show where you are
set scrolloff=3                                              " show context above/below cursorline
set shiftwidth=2                                             " normal mode indentation commands use 2 spaces
set showcmd
set smartcase                                                " case-sensitive search if any caps
set softtabstop=2                                            " insert mode tab and backspace use 2 spaces
set tabstop=4                                                " actual tabs occupy 8 characters
set wildignore=log/**,node_modules/**,target/**,tmp/**,*.rbc
set wildmenu                                                 " show a navigable menu for tab completion
set wildmode=longest,list,full
set showmatch              " brackets/braces that is
set mat=5                  " duration to show matching brace (1/10 sec)
set history=1000
set undolevels=1000
set wildignore=*.swp,*.bak,*.pyc,*.class
set title
set visualbell
set noerrorbells
set nobackup
set noswapfile
setlocal formatoptions=ctnqro

" Tell vim to remember certain things when we exit
"  '10  :  marks will be remembered for up to 10 previously edited files
"  "100 :  will save up to 100 lines for each register
"  :20  :  up to 20 lines of command-line history will be remembered
"  %    :  saves and restores the buffer list
"  n... :  where to save the viminfo files
set viminfo='10,\"100,:20,%,n~/.viminfo

" Enable basic mouse behavior such as resizing buffers.
set mouse=a
if exists('$TMUX')  " Support resizing in tmux
  set ttymouse=xterm2
endif

" Appearance
set cursorline
set t_Co=256
set background=dark
if !exists('g:colors_name') || g:colors_name !=# 'solarized'
  colorscheme solarized
endif
let g:solarized_termcolors=256
let g:solarized_termtrans=1
let g:solarized_bold=1
let g:solarized_underline=1
let g:solarized_italic=1
let g:solarized_visibility=1
hi clear LineNr

" keyboard shortcuts
let mapleader = ','
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

nnoremap <CR> :nohlsearch<CR>

let g:jkjk=0
function! ToggleJKJK()
  if g:jkjk == 0
    let g:jkjk = 1
    noremap <c-j> :only<cr>:bnext<cr>
    noremap <c-k> :only<cr>:bprev<cr>
  else
    let g:jkjk = 0
    noremap <C-j> <C-w>j
    noremap <C-k> <C-w>k
  endif
endfunction
noremap <leader>u :call ToggleJKJK()<CR>

noremap <leader>l :Align
nnoremap <leader>a :Ag<space>
nnoremap <leader>b :CtrlPBuffer<CR>
nnoremap <leader>d :NERDTreeToggle<CR>
nnoremap <leader>f :NERDTreeFind<CR>
nnoremap <leader>t :CtrlP<CR>
nnoremap <leader>T :CtrlPClearCache<CR>:CtrlP<CR>
nnoremap <leader>] :TagbarToggle<CR>
nnoremap <leader><space> :%s/\s*$//g \| :nohlsearch<CR>
nnoremap <leader>g :GitGutterToggle<CR>
function! RefreshUI()
  filetype detect
  if exists(':AirlineRefresh')
    AirlineRefresh
  else
    " Clear & redraw the screen, then redraw all statuslines.
    redraw!
    redrawstatus!
  endif
  syntax sync fromstart
endfunction
noremap <silent> <leader>V :source ~/.vimrc \| :call RefreshUI() \|  :exe ":echo 'vimrc reloaded'"<CR>
nmap <silent> <leader>ev :e $MYVIMRC<CR>
set pastetoggle=<F2> " Fix large paste
" use ';' rather than ':' for w or wq
nnoremap ; :
" Forget arrow keys, bitch
map <up> <nop>
map <down> <nop>
map <left> <nop>
map <right> <nop>
" Buffers
function DeleteHiddenBuffers()
  let tpbl=[]
  call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
  for buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val)==-1')
    silent execute 'bwipeout' buf
  endfor
endfunction
nmap <leader>k :call DeleteHiddenBuffers()<cr>
nmap <c-c> :bd<cr>
nmap <s-k> :ls<cr>

" Finally can sudo after a file is openned
cmap w!! w !sudo tee % >/dev/null
" in case you forgot to sudo
" cnoremap w!! %!sudo tee > /dev/null %

" Be able to scroll wrapped lines of text
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

" Rename current file
function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'))
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
:command! RenameFile :call RenameFile()
map <leader>q :RenameFile<cr>
" Epix to return the cursor to position of last open session
au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
      \| exe "normal g'\"" | endif

" plugin settings
let g:NERDSpaceDelims=1
let g:gitgutter_enabled = 0

" Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
if executable('ag')
  " Use Ag over Grep
  set grepprg=ag\ --nogroup\ --nocolor\ --column

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_switch_buffer = 0
  let g:ctrlp_working_path_mode = 'ra'
  let g:ctrlp_use_caching = 1
  "let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:15,results:10'
  let g:ctrlp_match_window = 'order:btt,max:10'
  " let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden -g ""'
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden
          \ --smart-case
          \ --ignore .git
          \ --ignore .svn
          \ --ignore .hg
          \ --ignore .DS_Store
          \ --ignore public/images
          \ --ignore tmp
          \ --ignore node_modules
          \ --ignore log
          \ --ignore "**/*.pyc"
          \ --ignore "**/*.so"
          \ --ignore "**/*.dll"
          \ --ignore "**/*.exe"
          \ -g ""'
  " let g:ctrlp_user_command = ['ag %s -l --nocolor -g ""']
  " let g:ctrlp_user_command = ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard']
endif
let g:ctrlp_custom_ignore = {
\ 'dir':  '\v[\/](\.git|\.hg|\.svn|\.yardoc|public\/images|public\/system|data|log|tmp|node_modules|.DS_Store|vendor)$',
\ 'file': '\v\.(exe|so|dll)$',
\ }

" fdoc is yaml
autocmd BufRead,BufNewFile *.fdoc set filetype=yaml
" md is markdown
autocmd BufRead,BufNewFile *.md set filetype=markdown
autocmd BufRead,BufNewFile *.md set spell
" extra rails.vim help
autocmd User Rails silent! Rnavcommand decorator      app/decorators            -glob=**/* -suffix=_decorator.rb
autocmd User Rails silent! Rnavcommand observer       app/observers             -glob=**/* -suffix=_observer.rb
autocmd User Rails silent! Rnavcommand feature        features                  -glob=**/* -suffix=.feature
autocmd User Rails silent! Rnavcommand job            app/jobs                  -glob=**/* -suffix=_job.rb
autocmd User Rails silent! Rnavcommand mediator       app/mediators             -glob=**/* -suffix=_mediator.rb
autocmd User Rails silent! Rnavcommand stepdefinition features/step_definitions -glob=**/* -suffix=_steps.rb
autocmd Filetype ruby set lazyredraw
" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

" Fix Cursor in TMUX
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" Don't copy the contents of an overwritten selection.
vnoremap p "_dP

" Go crazy!
if filereadable(expand("~/.vimrc.local"))
  " In your .vimrc.local, you might like:
  "
  " set autowrite
  " set nocursorline
  " set nowritebackup
  " set whichwrap+=<,>,h,l,[,] " Wrap arrow keys between lines
  "
  " autocmd! bufwritepost .vimrc source ~/.vimrc
  " noremap! jj <ESC>
  source ~/.vimrc.local
endif

" Neocomplete thangs
let g:acp_enableAtStartup = 0
set completeopt-=preview
let g:neocomplete#enable_at_startup = 0
autocmd FileType ruby nested NeoCompleteLock
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
    \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Complete key-mappings.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif

let g:neocomplete#sources#syntax#min_keyword_length = 3

" Airline
let g:airline_theme='solarized'
let g:airline_powerline_fonts = 1
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
let g:airline_symbols.space = "\ua0"

" Ruby
let g:ruby_indent_access_modifier_style="indent"

" Splits
set splitbelow
set splitright

"hi TabLine guibg=NONE guifg=NONE
"hi SpecialKey guifg=NONE ctermfg=NONE ctermbg=NONE guibg=NONE
hi SpecialKey guibg=NONE guifg=NONE ctermfg=NONE ctermbg=NONE
hi TabLine guibg=NONE guifg=NONE ctermfg=NONE ctermbg=NONE

let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
let g:syntastic_mode_map = { 'mode': 'passive', 'active_filetypes': [],'passive_filetypes': ['go'] }
